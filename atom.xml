<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>餘</title>
  
  <subtitle>三餘讀書</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yk1n0rt.github.io/"/>
  <updated>2018-09-02T16:00:00.000Z</updated>
  <id>https://yk1n0rt.github.io/</id>
  
  <author>
    <name>yk1n0rt</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大道至簡Hexo</title>
    <link href="https://yk1n0rt.github.io/2018/09/03/%E5%A4%A7%E9%81%93%E8%87%B3%E7%B0%A1Hexo/"/>
    <id>https://yk1n0rt.github.io/2018/09/03/大道至簡Hexo/</id>
    <published>2018-09-02T16:00:00.000Z</published>
    <updated>2018-09-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大道至簡Hexo"><a href="#大道至簡Hexo" class="headerlink" title="大道至簡Hexo"></a>大道至簡Hexo</h1><p>Hexo 是一個由<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>構建的快速、簡單且強大的網誌框架。</p><h1 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h1><h2 id="安裝環境"><a href="#安裝環境" class="headerlink" title="安裝環境"></a>安裝環境</h2><p>Mac用戶在編譯時可能會碰到問題，請先至 App Store 安裝 Xcode，一旦 Xcode 安裝完成後，開啟它並前往 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安裝命令列工具。</p><h3 id="安裝Node-js"><a href="#安裝Node-js" class="headerlink" title="安裝Node.js"></a>安裝Node.js</h3><p>既然是由Node.js構建的網志框架，那必可不少的環境之一肯定是<a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a>。這裏通過安裝包一鍵安裝，亦可通過本地編譯完成安裝。<br>安裝 Node.js 的最佳方式是透過 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">Node Version Manager</a>。感謝 nvm 的開發者提供簡易自動安裝的腳本指令：<br>cURL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>Wget:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>一旦安裝完成，重啟終端機並執行下列指令以安裝 Node.js。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></table></figure></p><h3 id="安裝Git"><a href="#安裝Git" class="headerlink" title="安裝Git"></a>安裝Git</h3><p>安裝Git的最佳方式是透過<a href="https://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>安裝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure></p><h3 id="安裝Hexo"><a href="#安裝Hexo" class="headerlink" title="安裝Hexo"></a>安裝Hexo</h3><p>在終端下執行下列指令以安裝Hexo。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><p>截至目前，便完成了Hexo的基本安裝。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>配置內容，比較複雜，供參考學習的資料網路上也是非常的多，但還是推薦也通讀一遍<a href="https://hexo.io/zh-tw/docs/" target="_blank" rel="noopener">Hexo官方文檔</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>如此網誌便已完成建立，在<folder>中會出現以下目錄</folder></p><ul><li>_config.yml /<em>網站的配置文檔 </em>/</li><li>package.json /<em>nodejs的安裝包目錄 </em>/</li><li>scaffolds /<em>當您建立新文章時，Hexo 會根據 scaffold 來建立檔案</em>/</li><li>source /<em>原始檔案資料夾，放置檔案內容</em>/<ul><li>_drafts</li><li>_posts</li><li>themes /<em>主題資料夾</em>/<h1 id="應用"><a href="#應用" class="headerlink" title="應用"></a>應用</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2></li></ul></li><li>init<br><code>$ hexo init [folder]</code><br>建立一個新的網站。如果沒有設定 folder 的話，Hexo 會在目前的資料夾建立網站。</li><li>new<br><code>$ hexo new [layout] &lt;title&gt;</code><br>建立一篇新的文章。如果沒有設定 layout 的話，則會使用 _config.yml 中的 default_layout 設定代替。如果標題包含空格的話，請使用引號括起來。</li><li>generate<br><code>$ hexo generate</code><br>產生靜態檔案。<br>-d, –deploy    產生完成即部署網站<br>-w, –watch    監看檔案變更</li><li>publish<br><code>$ hexo publish [layout] &lt;filename&gt;</code><br>發表草稿。</li><li>server<br><code>$ hexo server</code><br>啟動伺服器，預設是 <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a><br>-p, –port    覆蓋連接埠設定<br>-s, –static    只使用靜態檔案<br>-l, –log    啟動記錄器，或覆蓋記錄格式</li><li>deploy<br><code>$ hexo deploy</code><br>部署網站。<br>-g, –generate    部署網站前先產生靜態檔案</li><li>render<br><code>$ hexo render &lt;file&gt; [file2] ...</code><br>渲染檔案。<br>-o, –output    輸出位置</li><li>migrate<br><code>$ hexo migrate &lt;type&gt;</code><br>從其他系統 轉移內容。</li><li>clean<br><code>$ hexo clean</code><br>清除快取檔案 (db.json) 和已產生的靜態檔案 (public)。</li><li>list<br><code>$ hexo list &lt;type&gt;</code><br>列出網站資料。</li><li><p>version<br><code>$ hexo version</code><br>顯示版本資訊。</p><ul><li>安全模式<code>hexo --safe</code><pre><code>在安全模式下，不會載入外掛和腳本。當您在安裝新外掛後遭遇問題時，可以嘗試以安全模式重新執行。</code></pre></li><li>除錯模式<code>hexo --debug</code><pre><code>在終端機中顯示除錯訊息並儲存記錄檔到 debug.log。當您碰到問題時，試著以除錯模式重新執行一次，並 把除錯訊息貼到 GitHub。</code></pre><ul><li>安靜模式<code>hexo --silent</code><br>   隱藏終端機的訊息。</li></ul></li></ul></li><li><p>自訂配置檔的路徑<br><code>$ hexo --config custom.yml</code><br>自訂配置檔的路徑而不是使用 _config.yml。此參數也接受以逗號分隔的 JSON 或 YAML 檔列表字串 (不得含有空格)，它們將會被合併產生一個 _multiconfig.yml。<br><code>$ hexo --config custom.yml,custom2.json</code><br>顯示草稿<br><code>$ hexo --draft</code><br>顯示 source/_drafts 資料夾中的草稿文章。<br>自定 CWD<br><code>$ hexo --cwd /path/to/cwd</code><br>自訂目前工作目錄（Current working directory）的路徑。 </p></li></ul><p>立個flag：<strong>9月底完成對hexo的詳細剖析</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;大道至簡Hexo&quot;&gt;&lt;a href=&quot;#大道至簡Hexo&quot; class=&quot;headerlink&quot; title=&quot;大道至簡Hexo&quot;&gt;&lt;/a&gt;大道至簡Hexo&lt;/h1&gt;&lt;p&gt;Hexo 是一個由&lt;a href=&quot;http://nodejs.org/&quot; target=&quot;
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://yk1n0rt.github.io/tags/Hexo/"/>
    
      <category term="Github" scheme="https://yk1n0rt.github.io/tags/Github/"/>
    
      <category term="Nodejs" scheme="https://yk1n0rt.github.io/tags/Nodejs/"/>
    
      <category term="大道" scheme="https://yk1n0rt.github.io/tags/%E5%A4%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>surge 2.5.3無限期試用教程</title>
    <link href="https://yk1n0rt.github.io/2018/09/02/surge%202.5.3%E7%84%A1%E9%99%90%E6%9C%9F%E8%A9%A6%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://yk1n0rt.github.io/2018/09/02/surge 2.5.3無限期試用教程/</id>
    <published>2018-09-01T16:00:00.000Z</published>
    <updated>2018-09-02T15:28:53.426Z</updated>
    
    <content type="html"><![CDATA[<p>本文僅以探討 <strong><a href="https://github.com/wolfcw/libfaketime" target="_blank" rel="noopener">libfaketime</a></strong>的功能，請在surge試用期到期後，購買正版或卸載。</p><h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>根據README文檔的描述，libfaketime攔截程序用於檢索系統當前日期和時間的各種系統調用，然後將修改（或是僞造）的日期和時間（由用戶自身指定）報告給這些程序，它允許修改程序看到的系統時間，而不需要在系統時間處更改時間，從而不影響其它應用對本地時間的調用。<br>以下內容來自直接拷貝於 <strong><a href="https://github.com/wolfcw/libfaketime" target="_blank" rel="noopener">libfaketime</a></strong>，詳細瞭解，請跳轉鏈接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">2、 Compatibility issues</span><br><span class="line">-----------------------</span><br><span class="line">- libfaketime is supposed to work on Linux and macOS.</span><br><span class="line">  Your mileage may vary; some other *NIXes have been reported to work as well.</span><br><span class="line">- libfaketime uses the library preload mechanism of your operating system&apos;s</span><br><span class="line">  linker (which is involved in starting programs) and thus cannot work with</span><br><span class="line">  statically linked binaries or binaries that have the setuid-flag set (e.g.,</span><br><span class="line">  suidroot programs like &quot;ping&quot; or &quot;passwd&quot;). Please see you system linker&apos;s</span><br><span class="line">  manpage for further details.</span><br><span class="line">- libfaketime supports the pthreads environment. A separate library is built</span><br><span class="line">  (libfaketimeMT.so.1), which contains the pthread synchronization calls. This</span><br><span class="line">  library also single-threads calls through the time() intercept because</span><br><span class="line">  several variables are statically cached by the library and could cause issues</span><br><span class="line">  when accessed without synchronization.</span><br><span class="line">  However, the performance penalty for this might be an issue for some</span><br><span class="line">  applications. If this is the case, you can try using an unsynchronized time()</span><br><span class="line">  intercept by removing the -DPTHREAD_SINGLETHREADED_TIME from the Makefile and</span><br><span class="line">  rebuilding libfaketimeMT.so.1</span><br><span class="line">* Java-/JVM-based applications work but you need to pass in an extra argument</span><br><span class="line">  (DONT_FAKE_MONOTONIC).  See usage basics below for details.  Without this</span><br><span class="line">  argument the java command usually hangs.</span><br><span class="line">* libfaketime will eventually be bypassed by applications that dynamically load</span><br><span class="line">  system libraries, such as librt, explicitly themselves instead of relying on</span><br><span class="line">  the linker to do so at application start time. libfaketime will not work with</span><br><span class="line">  those applications unless you can modify them.</span><br><span class="line">* Applications can explicitly be designed to prevent libfaketime from working,</span><br><span class="line">  e.g., by checking whether certain environment variables are set or whether</span><br><span class="line">  libfaketime-specific files are present.</span><br></pre></td></tr></table></figure></p><h1 id="對surge的應用"><a href="#對surge的應用" class="headerlink" title="對surge的應用"></a>對surge的應用</h1><h2 id="安裝libfaketime"><a href="#安裝libfaketime" class="headerlink" title="安裝libfaketime"></a>安裝libfaketime</h2><p>1、安裝Homebrew<br>Mac下直接在終端下輸入下述命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><p>Homebrew安裝成功後，可通過<strong>brew -v</strong>顯示Homebrew的版本號<br>2、Homebrew的基本操作</p><ul><li>安裝軟件：brew install &lt;軟件&gt;</li><li>搜索軟件：brew search &lt;軟件&gt;</li><li>卸載軟件：brew uninstall &lt;軟件&gt;<br>3 、安裝libfaketime<br>通過終端安裝libfaketime和coreutils（由於依賴GNU時間，需要安裝coreutils），輸入下述命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install libfaketime coreutils</span><br></pre></td></tr></table></figure></li></ul><p>安裝成功後，可在終端輸入<strong>faketime</strong>來查看libfaketime是否安裝成功。</p><h2 id="修改Surge調用的系統時間"><a href="#修改Surge調用的系統時間" class="headerlink" title="修改Surge調用的系統時間"></a>修改Surge調用的系統時間</h2><p>直接通過faketime來運行Surge，並且爲程序單獨僞造系統時間2018年9月1日。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">faketime &apos;2018-09-01 00:00:00&apos; /Applications/Surge.app/Contents/MacOS/Surge &amp;</span><br></pre></td></tr></table></figure></p><p>如此，便能看到Surge成功以2018年9月1日的時間運行。</p><h2 id="其它說明的問題"><a href="#其它說明的問題" class="headerlink" title="其它說明的問題"></a>其它說明的問題</h2><ul><li>此方法僅用於Surge2.5.3之前的各個版本的試用測試</li><li>若系統上已安裝過新版本或提示“試用期已過，請重新授權”之類的話，此方法無效</li><li>libfaketime可能會佔用大量CPU資源，可嘗試添加<strong>FAKETIME_STOP_AFTER_SECONDS=10</strong>(在程序啓動後10秒後，自動關閉libfaketime進程）</li><li>關閉libfaketime進程後，Surge的配置選項中，會顯示剩餘負數天數</li><li>參考鏈接中，更是給出了通過配合Alfred的Workflow的效果，本文不作討論<h1 id="libfaketime亦可對Docker的具體應用做僞造系統時間"><a href="#libfaketime亦可對Docker的具體應用做僞造系統時間" class="headerlink" title="libfaketime亦可對Docker的具體應用做僞造系統時間"></a>libfaketime亦可對Docker的具體應用做僞造系統時間</h1></li></ul><p>參考鏈接：<a href="https://www.daletan.win/2017/10/27/surge-for-mac-trial-crack/" target="_blank" rel="noopener">子與孟子曰</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文僅以探討 &lt;strong&gt;&lt;a href=&quot;https://github.com/wolfcw/libfaketime&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;libfaketime&lt;/a&gt;&lt;/strong&gt;的功能，請在surge試用期到期後，購
      
    
    </summary>
    
    
      <category term="surge" scheme="https://yk1n0rt.github.io/tags/surge/"/>
    
      <category term="libfaketime" scheme="https://yk1n0rt.github.io/tags/libfaketime/"/>
    
      <category term="試用" scheme="https://yk1n0rt.github.io/tags/%E8%A9%A6%E7%94%A8/"/>
    
      <category term="Homebrew" scheme="https://yk1n0rt.github.io/tags/Homebrew/"/>
    
  </entry>
  
  <entry>
    <title>Navicat Premium for Mac 破解教程</title>
    <link href="https://yk1n0rt.github.io/2018/09/01/Navicat%20Premium%20for%20Mac%E7%A0%B4%E8%A7%A3%E6%95%99%E7%A8%8B/"/>
    <id>https://yk1n0rt.github.io/2018/09/01/Navicat Premium for Mac破解教程/</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2018-09-01T14:21:39.145Z</updated>
    
    <content type="html"><![CDATA[<p>本文僅以探討破解思路，請支持正版</p><h1 id="破解思路"><a href="#破解思路" class="headerlink" title="破解思路"></a>破解思路</h1><p>替換RSA加密算法公匙（Navicat Premium for Mac中的公匙位於程序包目錄的rpk文件中）</p><h1 id="生成自己的RSA公匙私匙對"><a href="#生成自己的RSA公匙私匙對" class="headerlink" title="生成自己的RSA公匙私匙對"></a>生成自己的RSA公匙私匙對</h1><p>使用open ssl工具生成，當然也可以使用其它工具<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener">在線生成工具</a>生成，這裏需要注意的是<code>密匙是2048位，PKCS#8格式</code></p><h1 id="替換RSA公匙"><a href="#替換RSA公匙" class="headerlink" title="替換RSA公匙"></a>替換RSA公匙</h1><ul><li>版本12.0.24之前，公匙存儲在<strong>Navicat Premium.app/Contents/Resources/rpk</strong>，用文本編輯器打開它，替換上述生成的公匙</li><li>12.0.24之後，公匙不再存儲在<strong>Navicat Premium.app/Contents/Resources/rpk</strong>中，而是放在了Navicat的二進制執行文件<strong>Navicat Premium.app/Contents/MacOS/Navicat Premium</strong>中，通過搜索<code>-----BEGIN PUBLIC KEY-----</code>找到它<h1 id="算出有效的Mac版序列號密匙"><a href="#算出有效的Mac版序列號密匙" class="headerlink" title="算出有效的Mac版序列號密匙"></a>算出有效的Mac版序列號密匙</h1></li><li><p>序列號是一個16字節長度的字符串，是經過Base32編碼的，其實際存儲長度爲80位（8字節），輸入密匙後程序仍然會用Base33編碼，以二進制形式存儲比對。<br>正常的Base32編碼表順序是<br><code>char EncodeTable[]=‘ABCDEFGHIJKLMNOPQRSTUVWXYZ234567’</code><br>80位長的二進制數據，可轉換成爲10個十六進制，如<br>第壹個8位二進制數據：68 /原作者表示不知是什麼，但不能改變；<br>第貳個8位二進制數據：2A /原作者表示不知是什麼，但不能改變；<br>第叄個8位二進制數據：00 /原作者表示不知是什麼，但可任意改變；<br>第肆個8位二進制數據：00 /原作者表示不知是什麼，但可任意改變；<br>第伍個8位二進制數據：00 /原作者表示不知是什麼，但可任意改變；<br>第陸個8位二進制數據：AA /第陸個和第柒個組合使用；<br>第柒個8位二進制數據：99 /第陸個和第柒個組合使用，目前已知0xAC 0x88代表英文版，0xCE 0x32代表簡體中文版，0xAA 0x99代表繁體中文版，0xAD 0x82代表日本語，0xBB 0x55代表Polski，0xAE 0x10代表Español，0xFA 0x20代表Français，0xB1 0x60代表Deutsch，0xB5 0x60代表한국어，0xEE 0x16代表Русский，0xCD 0x49代表Português；<br>第捌個8位二進制數據：65 /代表商業許可類型，0x65代表企業版，0x66代表教育版，0x67代表精簡版；（以上數據爲Navicat12版本）<br>第玖個8位二進制數據：C0 /這個8位數據的前4位必須是1100，轉換爲十進制就是12，代表版本12，數據的後4位不知道代表什麼，但是可以延遲激活使用時間，後4位可以是0000或0001；（以上數據爲Navicat12版本）<br>第拾個8位二進制數據：FF /代表許可的期限權利類型，0xFB代表30天不可轉售許可，0xFC代表90天不可轉售許可，0xFD代表365天不可轉售許可，0xFE代表不可轉售許可，0xFF代表站點許可；<br>如此，得到繁體中文版密匙的原始數據：<code>68 2A 00 00 00 AA 99 65 C0 FF</code></p></li><li><p>對密匙後8個8位數據進行DES對稱加密，使用DES加密算法，並採用ECB模式。這裏，需要加密的是爲<code>00 00 00 AA 99 65 C0 FF</code>，DES加密密匙是<code>unsigned char DESKey = { 0x64, 0xAD, 0xF3, 0x2F, 0xAE, 0xF2, 0x1A, 0x27 }</code>，計算得出加密後的序列號密匙數據，並將原始數據轉化爲二進制，按每5位一組，進行Base32編碼，轉爲十進制，按找Base32編碼表，便能得到了相應版本的密匙。</p><h1 id="解密激活請求碼，生成激活碼"><a href="#解密激活請求碼，生成激活碼" class="headerlink" title="解密激活請求碼，生成激活碼"></a>解密激活請求碼，生成激活碼</h1></li><li>啓動程序後，提示註冊，<strong>斷開網路，阻止程序聯網</strong>，然後點擊註冊</li><li>根據提示，點擊手動激活，彈出離線激活請求，得到了程序給處的請求碼（這是一個Base64編碼的字符串，代表的是長度爲256字節的數據，這是離線激活請求信息被激活公匙加密的密文</li><li>經過RSA配對的私匙解密後，能得到激活請求信息（json風格）<br><code>{  “K“: “xxxxxxxxxxxxxxxx”，  “P”: “Mac 10.13”，  “DI”: “xxxxxxxxxxxxxxxxxxxx”}</code>這裏包含了3個key：“K”、“DI”、“P”，分別代表序列號、設備識別碼（與電腦硬件信息相關）和平臺（操作系統類型）</li><li>仍然通過RSA配對的私匙，使用上述的“K”和“DI”信息的json風格<br><code>{  “DI” : “xxxxxxxxxxxxxxxxxxxx”,  “T” : “1535808471.925012”,  “K” : “xxxxxxxxxxxxxxxx”,  “N” : “DoubleLabyrinth”,  “O” : “Shadow”}</code>這裏包含了5個key：“K”、“DI”、“N”、“T” 、“O”，分別代表序列號、設備識別碼（與電腦硬件信息相關）、註冊名、授權時間、組織。<strong>其中“T”是必須的，且代表的時間必須位於當前時間-1~+4天之內，採用的是unix時間戳</strong></li><li>輸入得到的離線激活回覆信息，激活完畢。</li></ul><p>參考鏈接：<br><a href="https://github.com/DoubleLabyrinth/navicat-keygen.git" target="_blank" rel="noopener">Double Sine</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文僅以探討破解思路，請支持正版&lt;/p&gt;
&lt;h1 id=&quot;破解思路&quot;&gt;&lt;a href=&quot;#破解思路&quot; class=&quot;headerlink&quot; title=&quot;破解思路&quot;&gt;&lt;/a&gt;破解思路&lt;/h1&gt;&lt;p&gt;替換RSA加密算法公匙（Navicat Premium for Mac中的公
      
    
    </summary>
    
    
      <category term="Navicat" scheme="https://yk1n0rt.github.io/tags/Navicat/"/>
    
      <category term="加密與解密" scheme="https://yk1n0rt.github.io/tags/%E5%8A%A0%E5%AF%86%E8%88%87%E8%A7%A3%E5%AF%86/"/>
    
      <category term="unix" scheme="https://yk1n0rt.github.io/tags/unix/"/>
    
  </entry>
  
</feed>
